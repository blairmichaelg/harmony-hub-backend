# Utility Module Management Plan

## Objective

Provide a comprehensive set of reusable utility functions for the HarmonyHub backend, promoting code maintainability, readability, and consistency. This module will be tightly integrated with the configuration management system, allowing for flexible and configurable behavior across different aspects of the application.

## Components

1.  **audio/**

    *   **Objective:** Handle audio-specific operations, deeply integrated with `AudioProcessingConfig`.

    *   **Sub-Modules:**

        *   **`formats.ts`:**
            *   `getSupportedAudioFormats()`: Returns supported audio formats from `audioProcessingConfig`.
            *   `isAudioFormatSupported(extension: string)`: Checks if an extension is supported using `audioProcessingConfig`.
            *   `getAudioFormatInfo(extension: string)`: Retrieves format details (MIME type, codec) from `audioProcessingConfig`.
        *   **`analysis.ts`:**
            *   `calculateRMS(audioBuffer: Float32Array)`: Calculates the Root Mean Square (RMS) of an audio buffer.
            *   `generateWaveform(audioBuffer: Float32Array, width: number): number[]`: Generates a simplified waveform for visualization.
            *   `extractAudioMetadata(filePath: string): Promise<AudioMetadata>`: Extracts audio metadata (using external libraries if necessary).
        *   **`effects.ts`:**
            *   `applyReverb(audioBuffer: Float32Array, settings: ReverbSettings): Promise<Float32Array>`: Applies reverb using validated `ReverbSettings`.
            *   `applyEqualization(audioBuffer: Float32Array, bands: EQBand[]): Promise<Float32Array>`: Applies EQ using validated `EQBand` settings.
        *   **`validation.ts`:**
            *   `ReverbSettings`: Zod schema matching `audioProcessingConfig.effects.reverb.presets`.
            *   `EQBand`: Zod schema matching `audioProcessingConfig.effects.equalization.bands`.
2.  **string/**

    *   **Objective:** Handle string manipulation, sanitization, and validation.

    *   **Sub-Modules:**

        *   **`sanitize.ts`:**
            *   `sanitizeForSearch(str: string): string`: Prepares strings for search queries.
            *   `sanitizeHTML(str: string): string`: Sanitizes HTML input to prevent XSS (consider using `DOMPurify`).
            *   `anonymizeLogData(str: string, fields: string[]): string`: Anonymizes sensitive log data based on `LoggingConfig.anonymization`.
3.  **validation/**

    *   **Objective:** Centralize data validation logic using Zod.

    *   **Sub-Modules:**

        *   **`audio.ts`:** Contains Zod schemas for validating audio-related data.
4.  **`async.ts`**

    *   **Objective:** Simplify asynchronous operations.

    *   **Functions:**

        *   `sleep(ms: number): Promise<void>`: Pauses execution asynchronously for a given number of milliseconds.
        *   `retry(fn: () => Promise<T>, retries: number, delay: number): Promise<T>`: Retries a function with exponential backoff on failure.
        *   **Consider:** Adding functions for working with asynchronous iterators, especially if dealing with large audio data streams.
5.  **`caching.ts`**

    *   **Objective:** Provide caching mechanisms aligned with `CacheConfig`.

    *   **Functions:**

        *   `getCachedValue(key: string): Promise<T | undefined>`: Retrieves cached values using `cacheConfig`.
        *   `setCachedValue(key: string, value: T, ttl?: number): Promise<void>`: Caches values using `cacheConfig` for TTL or an optional parameter.
        *   **Implement:** Distributed locking using `cacheConfig.distributedLock` to prevent cache stampede.
6.  **`crypto.ts`**

    *   **Objective:** Provide secure cryptographic operations aligned with `SecurityConfig`.

    *   **Functions:**

        *   `hashPassword(password: string): Promise<string>`: Securely hashes passwords using bcrypt (or Argon2) with settings from `securityConfig.bcrypt.saltRounds`.
        *   `generateRandomString(length: number): string`: Generates cryptographically secure random strings.
        *   `encrypt(data: string, secret: string): Promise<string>`: Encrypts data using a strong encryption algorithm (e.g., AES-256).
        *   **Consider:**  Adding functions for JWT signing/verification using `authConfig.jwt`.
7.  **`date.ts`**

    *   **Objective:** Manage date/time operations using Luxon, integrated with relevant config settings.

    *   **Functions:**

        *   `formatDateTime(date: DateTime, formatString: string): string`: Formats dates using Luxon.
        *   `getUTCOffset(timezone: string): string`: Gets the UTC offset for a given timezone.
        *   `calculateDuration(start: DateTime, end: DateTime): Duration`: Calculates the duration between two DateTime objects.
        *   **Add:** Functions to parse JWT expiration times from `authConfig.jwt.expiresIn`.
        *   **Add:** Functions to work with time durations (using Luxon's `Duration`) for caching (`CacheConfig`) and other time-sensitive operations.
        *   **Add:** Functions to format dates according to `LocalizationConfig.dateTimeFormat`.
8.  **`errorUtils.ts`**

    *   **Objective:** Define custom error classes for better error handling and reporting.

    *   **Classes:**

        *   `CustomError`: A base class for custom errors, extending the built-in `Error` class.
        *   **Add:** Specific error classes for different error scenarios in the application.
9.  **`file.ts`**

    *   **Objective:** Handle file system operations, integrated with `StorageConfig`.

    *   **Functions:**

        *   `getFileSize(filePath: string): Promise<number>`: Gets the size of a file in bytes.
        *   `createDirectoryIfNotExists(dirPath: string): Promise<void>`: Creates a directory if it doesn't exist.
        *   `streamFileToStorage(filePath: string): Promise<string>`: Streams files to the configured storage provider (`storageConfig`), handling different providers (S3, GCS, local).
        *   **Add:** Functions to validate file uploads against `storageConfig.uploadLimits` (e.g., `isValidFileSize`, `isValidMimeType`).
10. **`i18n.ts`**

    *   **Objective:** Handle internationalization and localization using `i18next` and `LocalizationConfig`.

    *   **Functions:**

        *   `translate(key: string, options?: i18next.TOptions): string`: Translates keys to the current language.
        *   `setLocale(locale: string): void`: Sets the current locale.
        *   **Add:** Functions to load translations based on `localizationConfig.translationFilePath`.
        *   **Add:** Functions to format numbers and currencies based on `localizationConfig.numberFormat`.
11. **`logging.ts`**

    *   **Objective:** Enhance logging functionality, integrating with `LoggingConfig` and a logging framework (e.g., Winston, Pino).

    *   **Functions:**

        *   `logRequest(req: Request, res: Response): void`: Logs HTTP requests based on `loggingConfig`.
        *   `logErrorWithStack(error: Error): void`: Logs errors with stack traces, respecting `loggingConfig`.
        *   `anonymizeLogData(logData: any): any`: Anonymizes log data based on `loggingConfig.anonymization`.
12. **`math.ts`**

    *   **Objective:** Provide mathematical functions for audio processing and analysis.

    *   **Functions:**

        *   `calculateAverage(numbers: number[]): number`: Calculates the average of an array of numbers.
        *   `convertDecibelToLinear(dB: number): number`: Converts decibels (dB) to a linear scale.
        *   **Add:** Project-specific functions for audio effects or analysis based on the project's DSP needs.
13. **`network.ts`**

    *   **Objective:** Manage network-related tasks.

    *   **Functions:**

        *   `isValidIP(ip: string): boolean`: Validates IP addresses.
        *   `parseURL(urlString: string): URL`: Parses URL strings.
14. **`performance.ts`**

    *   **Objective:** Measure and analyze performance, potentially using `PerformanceConfig`.

    *   **Functions:**

        *   `measureExecutionTime<T>(fn: () => T): Promise<[T, number]>`: Measures function execution time.
        *   **Add:** Functions to monitor resource usage (CPU, memory) based on `performanceConfig`.

## Functionality

1.  **Configuration Integration:**

    *   Utilize configuration values from the `config/` module to control the behavior of utility functions.
    *   Implement functions to access and parse configuration options relevant to each utility module.
2.  **Error Handling:**

    *   Implement centralized error handling using custom error classes defined in `errorUtils.ts`.
    *   Provide informative error messages and appropriate HTTP status codes.
    *   Log errors with stack traces for debugging purposes.
3.  **Validation:**

    *   Use Zod schemas for robust data validation across utility functions.
    *   Validate function inputs, outputs, and configuration options to ensure data integrity.
4.  **Security:**

    *   Follow security best practices in all utility functions, especially in `crypto.ts`.
    *   Use appropriate encryption algorithms and security measures based on `SecurityConfig`.
5.  **Performance:**

    *   Optimize performance-critical utility functions for efficiency.
    *   Utilize caching mechanisms where applicable, leveraging `CacheConfig`.
    *   Consider asynchronous operations and efficient data structures.

## Technologies

*   **TypeScript:** For type safety, code organization, and improved developer experience.
*   **Zod:** For schema validation and runtime type checking.
*   **Luxon:** For robust date and time operations.
*   **bcrypt/Argon2:** For secure password hashing.
*   **Winston/Pino:** For structured logging and integration with `LoggingConfig`.
*   **i18next:** For internationalization and localization.
*   **External Libraries:** Leverage well-established libraries for specific tasks (e.g., DOMPurify for HTML sanitization).

## Integration Points

*   Integrate with all other modules of the HarmonyHub backend to provide reusable utility functions.
*   Utilize the `config/` module extensively for configuration-driven behavior.
*   Integrate with logging, security, and performance monitoring modules.

## Performance Considerations

*   Profile and benchmark performance-critical utility functions.
*   Utilize caching mechanisms strategically.
*   Consider asynchronous operations for non-blocking behavior.
*   Choose efficient data structures and algorithms.

## Security Measures

*   Follow secure coding practices throughout the utility module.
*   Implement input validation and sanitization to prevent vulnerabilities.
*   Use strong encryption algorithms for sensitive data.
*   Adhere to security guidelines defined in `SecurityConfig`.

## Testing Strategy

*   Develop comprehensive unit tests for all utility functions.
*   Utilize mocking for external dependencies and configuration options.
*   Test error handling, validation, and edge cases.
*   Consider integration tests for complex scenarios.

## Future Expansions

*   Add more utility functions as needed to support new features and functionality.
*   Explore and integrate with additional external libraries to enhance capabilities.
*   Continuously optimize performance and security based on evolving requirements.
*   Implement a system for documenting and sharing utility functions across teams.

## Utility Template

```typescript
// src/utils/sampleUtil.ts

import { z } from 'zod';
import { config } from '../config';
import { CustomError } from './errorUtils';
import { logger } from './logging';

/**
 * Schema for complex input type
 */
const ComplexInputSchema = z.object({
  field1: z.string().describe('Description of field1'),
  field2: z.number().positive().describe('Description of field2'),
});

/**
 * Type definition for complex input
 */
type ComplexInput = z.infer<typeof ComplexInputSchema>;

/**
 * Processes a complex input and returns a result
 * @param {ComplexInput} input - The complex input to process
 * @returns {string} The processed result
 * @throws {CustomError} If input is invalid or processing fails
 */
export const processComplexInput = (input: ComplexInput): string => {
  try {
    // Validate input
    ComplexInputSchema.parse(input);

    // Process the input using configuration
    const result = `Processed ${input.field1} with config value ${config.aiServices.someValue}`;

    return result;
  } catch (error) {
    if (error instanceof z.ZodError) {
      logger.error('Input validation failed:', error.errors);
      throw new CustomError('Invalid input', 'INVALID_INPUT', 400);
    }
    logger.error('Processing failed:', error);
    throw new CustomError('Processing failed', 'PROCESSING_ERROR', 500);
  }
};

/**
 * Memoized utility function for expensive operations
 */
export const memoizedExpensiveOperation = (() => {
  const cache = new Map<string, number>();

  return (input: string): number => {
    if (cache.has(input)) {
      return cache.get(input)!;
    }

    // Simulate expensive operation
    const result = input.length * config.performance.complexFactor;
    cache.set(input, result);

    return result;
  };
})();

// Validate the utility functions
try {
  const sampleInput: ComplexInput = { field1: 'test', field2: 5 };
  processComplexInput(sampleInput);
  memoizedExpensiveOperation('test');
} catch (error) {
  logger.error('Utility function validation failed:', error);
  throw error;
}
```

### Consistencies Across Utility Files

1.  **Imports:**

    *   Import necessary modules and types: `import { z } from 'zod';`
    *   Import related configurations: `import { relevantConfig } from '../config/RelevantConfig';`
2.  **Function Definitions:**

    *   Use camelCase for function names: `export function utilityFunction() {...}`
    *   Provide type annotations for parameters and return types
    *   Use arrow functions for consistency: `export const utilityFunction = () => {...}`
3.  **Type Definitions:**

    *   Define types for complex data structures: `type ComplexType = {...};`
    *   Use Zod for runtime type checking where applicable
4.  **Error Handling:**

    *   Use try-catch blocks for error-prone operations
    *   Throw custom errors with descriptive messages
    *   Log errors before throwing them
5.  **Validation:**

    *   Use Zod schemas for validating input/output where appropriate
    *   Implement input validation at the beginning of functions
6.  **Configuration Integration:**

    *   Use imported configuration objects for dynamic behavior
    *   Avoid hardcoding values that should be configurable
7.  **Comments and Documentation:**

    *   Use JSDoc style comments for functions and types
    *   Provide detailed descriptions for parameters and return values
8.  **Performance Considerations:**

    *   Implement memoization for expensive operations
    *   Use efficient data structures and algorithms
9.  **Testing Considerations:**

    *   Design functions to be easily testable
    *   Avoid side effects where possible
10. **File Structure:**

    *   Start with a file-level comment describing the purpose of the utility file
    *   Order: imports, type definitions, function definitions
11. **Naming Conventions:**

    *   Use descriptive names for functions and variables
    *   Group related utilities in appropriately named files
12. **Extensibility:**

    *   Design utilities to be easily extensible for future additions

This updated template maintains consistency with the project structure and the config module. Here are the key changes and consistencies:

1.  **Imports:**
    *   Import the `config` object from the config module instead of individual config files.
    *   Use the `logger` from the logging utility instead of `console.log`.
2.  **Error Handling:**
    *   Use the `CustomError` class from `errorUtils.ts`.
    *   Use the `logger` for error logging.
3.  **Configuration Integration:**
    *   Access configuration values through the `config` object (e.g., `config.aiServices.someValue`).
4.  **File Structure:**
    *   The template follows the structure seen in other utility files in the project.
5.  **Naming Conventions:**
    *   Function and variable names use camelCase, consistent with the project style.
6.  **Type Definitions:**
    *   Use Zod for schema definitions and type inference.
7.  **Performance Considerations:**
    *   The memoization example is retained, using a configuration value from the performance config.
8.  **Validation:**
    *   Input validation using Zod is implemented at the beginning of functions.

This template ensures consistency across utility files and aligns with the config module and overall project structure. When creating new utility files or modifying existing ones, developers should follow this template and adapt it to the specific needs of each utility while maintaining the established conventions.

This template and the list of consistencies should be applied across all utility files to ensure uniformity, maintainability, and consistency with your config module in your project.